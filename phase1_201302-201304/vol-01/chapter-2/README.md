# 2-1　JavaScriptの基本的な記法

## コメントやnoscriptは必要？

ほぼ必要は無い。

- ガラケーの一部がjs未対応みたい。

## scriptコードはどこに書く？

1. scriptタグ内に埋め込み
1. 外部ファイル呼び出し

基本、外部ファイル。

## scriptタグの位置

1. 一般的：headタグ配下
1. 重い処理を描写最後に埋め込みたい：/body終了タグの直前
1. ajax処理結果等やむを得ない場合：bodyタグ内

## ルール

- 末尾にセミコロンつける

## コメント

注意：Browserから丸見えなので、あまり開発ちっくなコメントを書かない。

# 2-2　変数

## 宣言

`var 変数 = 初期値 ;`

- ※無くても動く。但し、global変数になってしまう（無駄にメモリに居続ける）ので避けるべき。
-- ちなみに、coffeescriptは宣言なしでもglobalにならない。


## 識別子

- 頭に数値はNG
- 記号は避けよう
- 予約語は避けよう

変数名、メソッド名等のネーミングは第3者に分かり易い名前に。

## 記法

- camelCase：変数名、関数名
- Pascal：クラス（コンストラクタ）
- アンダースコア：玉に変数名(camelならcamelで揃えるべき)

# 2-3　データ型

- 基本型
 - number：数値(MAX=???)
 - string：文字列
 - boolean：真偽
 - null：値が無い
 - undefined：明示的に値を代入していない
- 参照型
 - object：データの集合（名前でアクセス）
 - array：データの集合（インデックス番号でアクセス）
 - function：処理手続きの集合

※参照型は実際はobject型のみ。arrayは説明用。functionは今のjsの挙動から?

## リテラル

値の表現方法

- 数値
- 文字列(クオートで囲ったもの)
- ブーリアン(真偽）
- null
- 配列
- object
- 関数
- 正規表現


## 特徴

`数値の型が1つ`

- 実は内部では浮動小数点で管理しているらしい。

`nullとundefined`

- 整理
 - null : 積極的な意味付け
 - undefined : 単に未定義(後述)

- null
 - null型の取りうる値はnull値(リテラル)の1つだけ
 - リテラルのクラス調査するメソッド(後述)を試すと、なぜか、object型になる
  - (パーフェクトJSによると、jsのバグと主張する人もいるらしい)
> typeof null; // object

- undefined
 - undefined型はundefined値（定義済みグローバル変数）の１つだけ
 - リテラルのクラス調査するメソッド(後述)を試すと、undefined型になる
> typeof undefined; //undefined

- null と undefinedは == でtrue
- null と undefinedは === (後述)でfalse

`hashの代わりにobject`

`functionが独立している`

### 数値リテラル
- number
 - 整数リテラル
  - 10進数
  - 8進数
  - 16進数
 - 浮動小数点リテラル


## 文字列リテラル

シングルクオート、ダブルクオートいずれも可。

文字列の中で、クオート入れたい場合に、意識して違うクオートで文字列を囲う。

`"例えば'こんな風に'書いたり"`
`'あるいは"こんな風に"書いたり'`

（後述のエスケープシーケンスあれば、同じクオートも使える）

## エスケープシーケンス

よく使うヤツ
- ¥n：改行
- ¥r：復帰
- ¥t：タブ
- ¥'：シングルクォート
- ¥"：ダブルクォート

## 改行について

¥r¥n：改行されない

brタグを使う

## 配列

データの集合

- インデックス番号は0から始まる


### 書き方

- データ格納

`変数 = [内容1, 内容2]`

- データ追加

`変数.push(内容3)`

- データ読み込み

`配列名[インデックス番号]`


### 例

- 1

`x = [123, "abc", 3.14]`

`x[1] //"abc"`

- 2

`> y = [ [ "181cm", "59kg"], ["179cm", "65kg"]]`

`> y[1][0]  //179cm`

## object

連想配列。名前をキーにアクセスできるデータの集合。

### 書き方

- データ格納

`変数 = {キー名:値, キー名:値}`

- データ読み込み
 - ブラケット記法
  `変数[キー名]`
 - ドット演算子
  `変数.キー名`

- データ追加

`変数[キー名] = 値`

### 例

`tanaka = {"height":179, "weight":65}`

`tanaka["height"] //179`

`tanaka.weight //65`

`tanaka['age'] = 29`

## function

関数（処理の固まり）

### 例

`var 変数 = function(引数1, 引数2, ・・・) {関数の本体}`



## undefined

- 宣言済みだが値が入ってない変数

 `var x;`

 `document.writeln(x); //undefined`

- 未定義のプロパティを参照

 `var obj = {a:123};`

 `document.writeln(obj.b); //undefined`


# 2-4　演算子

- オペレータ
 - 算術演算子：+-等
 - 代入演算子：=等
 - 比較演算子：>等
 - 論理演算子： &&等
 - ビット演算子：&等
 - その他
- オペランド
 - リテラル
 - 変数

## 算術演算子：+-等

特殊なもののみ

- %：割り算のあまり
- ++：前(後)置加算
- --：前(後)置減算

### +のオペランドの型による動作の違い

- 数値同士：数の加算
- 文字列同士：文字の連結
- オブジェクト同士：オブジェクトを文字列形式に変換して連結。

### increment(++)/decrement(--)

`x++ => x = x + 1;`

- 前置演算

> var x = 1
>
> var y = x++; //1

1. yにx(=1)を代入
1. xに1を追加

- 後置演算

> var x = 1
>
> var y = ++x; //2

1. xに1を追加
1. yにx(=2)を代入

### 小数点

> 0.2 * 3
>
> = 0.6000000000000001

## 代入演算子：=等

### 複合代入演算子

`x += y`

`x = x + y`

### 基本型と参照型の代入の違い

- 基本型
 - 値渡し(シャローコピー)：値をそのまま格納
- 参照型
 - 参照渡し(ディープコピー)：メモリのアドレスを格納

## 比較演算子

- not equal
 - !=
 - hit markがnot

### ==(等価演算子)

- 基本型：データの型が違っても、"なんとなく"等しければTRUE

> 1 == true //true
> 
> 1 == "1" //true 
> 
> null == undefined //true
>

- 参照型：同じ値で、アドレスも全く同じでTRUE


> ["a","b","c"] == ["a","b","c"] // false
> 
> a = ["a","b","c"]
>
> b = a
> 
> a == b //true

### === 同値演算子

- データの型も値も同じであればTRUE

> "3.14E2" == 314 //true
>
> "3.14E2" == 314 //false
>
> '0x10' == 16 //true
> 
> '0x10' === 16 //false

- あまり使う事は無いような気がする。
 - 何かライブラリ系のソースリーディングしている際に出てくる程度？

### ==(等価演算子)と===(同値演算子)の違い

- == 等価演算子：データ型気にせず判定
- === 同値演算子：データ型気にして判定

### ３項演算子 / 条件演算子( ? : )

`条件式 ? trueの場合の式 : falseの場合の式`

> var x = 80;
>
> document.writeln((x >= 70) ? 'OK' : 'NG')

## 論理演算子

- && ||等、記号を２回繰り返す。
 - & | と書くと、ビット演算子になる。（後述）

### false

- 空文字("")
- 0
- NaN
- null
- undefined

### NaN

`Not a Number`
- 数値でない事を表す特殊な値。
 - 0除算、数値に変換出来ないオブジェクトを数値変換等
> 0 / 0 //"NaN
>
> Number("A") //"NaN"

- NaNは、==や===に対して常にfalse
 - NaN == NaN //false
- isNaNを使うとNaNで判定出来る
 - isNaN(NaN) //true
- NaN自体は型ではない。number型の一つみたい。

> typeof(NaN) // 'number'

### 論理演算子の短絡的評価

- x && y
- 左辺 論理演算子 右辺

`左辺の状態で結果が明らかである場合、右辺まで評価しない`

- true || false
 - 左辺のtrueだけで、右辺がtrueでもfalseでも、結果はtrue
  - なので、わざわざ右辺を評価しない
- false && true
 - 左辺のfalseだけで、右辺がtrueでもfalseでも、結果はfalse
  - なので、わざわざ右辺を評価しない

### ビット演算子

- 2進数の値に論理計算するもの。
 - 普通の四則演算より早い
  - 科学的な演算処理、暗号化、画像処理等、高い処理能力が必要な場合に使う。

- js上で使う事ないと思う。
 - 他の言語を参考にjs作った際に、基本的な演算子という事でつけてるだけかと思われ。

## その他の演算子

### delete

変数、配列、オブジェクトのプロパティを破棄

var宣言していたら、deleteしても値が残る。

※これも、あまり使わない気がする。

### typeof

データ型を返す。

> typeof 123 //'number'
>
> typeof 'abc' //'string'
>
> typeof true //'boolean'
>
> typeof null //'object' // bug? in perfect js
>
> typeof undefined // 'undefined'
>
> typeof [1,2,3] // 'object'
>
> typeof { "key" : "value" ,"key2" : "value2"} // 'object'
>

## 演算子の優先順位

- 決まった優先順位がある
 - 括弧が一番高い(恣意的に優先順位高めたければ括弧をつける)
 - かけ算、割り算が、足し算、引き算より優先。
- ルール１：優先順位の高い順に演算
- ルール２：優先順位が同じものは結合則に従う

### 結合則

- 基本は左から右に評価していく
- 代入演算子(=等)、単項(! delete等)／三項演算子(a?b:c)等が、逆に評価する
 - z = x+= 3 //右から先に評価

- program書くと自然とこうなるので、あまり表自体の意味が分からなくても気にしなくていいかと。

# 2-5　制御命令

- 順次
- 選択
- 反復

## 分岐 if

> if (条件式1) {
>
> 条件式1がtrueの場合実行する命令
>
> } else if (条件式2) {
>
> 命令2
>
> 条件式2がtrueの場合実行する命令
>
> } else {
>
> 全ての条件がfalseの場合実行する命令
>
> }
>

`複数の条件に合致しても、実行するのは、最初の１つのブロックだけ。`

`ネストできる`

- 中括弧{}は省略できるが、基本使わない事
 - 意図せぬ動作をする場合がある
 - 可読性が下がる

`条件式は=ではなく、==（等価演算子）`

## 多岐分岐 switch

- if)基本、if文だけで分岐は全部書ける。
 - 条件式は違う変数でも良い。同じ変数でも良い。
> if (a == 1) {
>
> 処理A
>
> } else if(a == 2) {
>
> 処理B
>
> } else {
>
> 処理C
>
> }

- switch)同じ変数に対して、並列に分岐しかできない。(ifの機能限定版)
 - ぱっと見、どの変数で並列の関係にあるのか？分かり易い。
 - なので、使える所は、積極的に使うべき。

> switch(a){
>
>   case 1:
>
>     処理A
>
>   case 2:
>
>     処理B
>
>     break;
>
>   default :
>
>     処理C
>
> }

`caseのブロック内にbreak;入れないとその下の処理も実行してしまうので、注意。`
 - 例えば、上記のcase1は処理A -> 処理B -> 処理Cを実行してしまう。

## LOOP

### while

- 条件を満たす限り、繰り返す。

- 初めに条件式(前値判定)
 - 条件式がtrue -> 処理実行 コレを繰り返す。

> while (条件式) {
>
> }
>

- 後ろに条件式(後値判定)
 - 処理実行 -> 条件式がtrueであれば、繰り返す。
 - ※条件式が後なので、最低１回は処理が実行される。

> do {
>
> } while(条件式)

- 意図せず無限LOOPになる場合あるので、利用は慎重に。


### 指定回数LOOP for文

指定した条件式が満たされる限り繰り返す

> for(初期化式; 条件式; 増減) {
>
>   命令
>
> }

例）

> > for(var x = 0; x < 10; x++) {
>
>   ... console.log(x)
>
>   ... }
>
>   0
>
>   1
>
>   2
>
>   3
>
>   4
>
>   5
>
>   6
>
>   7
>
>   8
>
>   9

- 初期値0から開始して、
- 1ずつ増加して、
- 10未満の9まで実行している

- カンマ演算子を使うと、複数の変数を扱えるが、
 - 複雑になるので、あまり使うべきではない。

### 配列内の要素を順に処理 for in

objectの反復処理を行う。

- 注意：他の言語のfor eachのイメージと少し違う(値でなく、キー)

>for (仮引数 in 配列/オブジェクト) {
>
>  命令
>
>}

- 配列

> > for(var x in ["a","b","c"]) {
>
>   ... console.log(x)
>
>   ... }
>
>   0
>
>   1
>
>   2

`値（a b c）でなく、配列のインデックス(0 1 2)が入る`
 - for文使うのと変わらないので、for文使った方がいい。
  - そもそも、この仕様が特殊。(ruby等普通は値が取れる。)
  - ちなみに、coffeescriptだと、ちゃんと値取れます。
 - objectの繰り返しなので、配列の中に配列以外のプロパティ等含むと、それも対象になるので注意。配列ではfor in使うべきでない。

- オブジェクト

> > for(var x in {"a" : "value1", "b" : "value2"}){
>
>   ... console.log(x);
>
>   ... }
>
>   a
>
>   b

objectの全値に対して何かしたい時に使う。

### break / continue

- break
 - ループを終了
- continue
 - 現在の周をスキップ

- ラベルを指定してbreakできるが、混乱するのであまり書かない方がいい。
 - それよりも、ロジック整理するべき。


### 例外処理 try catch finally

意図しないエラー(＝例外)発生時の処理を明示してスクリプト停止を防ぐ。

> try {
>
> 命令（例外発生するかもしれない）
>
> } catch (例外情報受け取り変数) {
>
> 例外発生時の命令
> 
> } finally {
> 
> 例外の有無にかかわらず、最終的に実行する命令
>
> }

- エラーになりそうな箇所をtryで囲むとエラー発生時、catch実行してくれる.
- finallyに、例外発生関わらず最終的に実行したい内容を書く。

### 例外発生

throw new Error(エラーメッセージ)

# おしまい

- 次は3/3です。

- 次の担当者は...
